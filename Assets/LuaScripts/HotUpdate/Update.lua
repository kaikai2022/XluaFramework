---
--- Generated by EmmyLua(https://github.com/EmmyLua)
--- Created by lucus.
--- DateTime: 29/9/2022 2:50 下午
---

---@class Update Lua热更新
local Update = BaseClass("Update")

function Update:__init()
    Logger.Log("开始初始化框架")
    self.gameLaunch = CS.UnityEngine.GameObject.Find("GameLuach"):GetComponent(typeof(CS.GameLaunch))
    UpdateManager:GetInstance():Startup()
    TimerManager:GetInstance():Startup()
    LogicUpdater:GetInstance():Startup()
    UIManager:GetInstance():Startup()
    coroutine.start(Bind(self, self._UpdateRes))
end

---@private _UpdateRes 更新资源
function Update:_UpdateRes()
    Logger.Log("开始检测更新")
    self:_GetPermission()
    self:_InitLaunchPrefab()
    self:_InitAppVersion()
    self:_InitChannel()
    self:_InitSDK()
    self:_InitNoticeTipPrefab()
    self:_WaitVideoPlayerEnd()
    self:_StartUpdateAssetRes()
end

---@private _GetPermission 获取权限
function Update:_GetPermission()
    Logger.Log("获取存储权限")
    Logger.Log(CS.UnityEngine.Application.platform)
    if CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.Android
    --        and (
    --        not CS.UnityEngine.Android.Permission.HasUserAuthorizedPermission(UnityEngine.Android.Permission.ExternalStorageWrite)
    --        or 
    --        not CS.UnityEngine.Android.Permission.HasUserAuthorizedPermission(UnityEngine.Android.Permission.ExternalStorageRead)
    --)
    then
        Logger.Log(CS.UnityEngine.RuntimePlatform.Android)
        if not CS.UnityEngine.Android.Permission.HasUserAuthorizedPermission(CS.UnityEngine.Android.Permission.ExternalStorageRead) then
            CS.UnityEngine.Android.Permission.RequestUserPermission(CS.UnityEngine.Android.Permission.ExternalStorageRead)
            print("获取 Android 读取权限")
        end
        if not CS.UnityEngine.Android.Permission.HasUserAuthorizedPermission(CS.UnityEngine.Android.Permission.ExternalStorageWrite) then
            CS.UnityEngine.Android.Permission.RequestUserPermission(CS.UnityEngine.Android.Permission.ExternalStorageWrite)
            print("获取 Android 写入权限")
        end
    end
    Logger.Log("获取权限结束")
end

---@private  _InitLaunchPrefab 初始化UI界面
function Update:_InitLaunchPrefab()
    ---初始化加载的prefab
    local launchPrefabPath = "UI/Prefabs/UILoading/UILoading.prefab"
    local loadingGameObject = ResourcesManager:GetInstance():CoLoadAsync(launchPrefabPath, typeof(CS.UnityEngine.GameObject))
    --coroutine.waitforfixedupdate()
    local go = CS.UnityEngine.GameObject.Instantiate(loadingGameObject)
    CS.UILauncher.Instance.UIGameObject = go
    UIManager:GetInstance():OpenWindow(UIWindowNames.UILoading)
    local loadingWin = UIManager:GetInstance():GetWindow(UIWindowNames.UILoading)
    coroutine.waitwhile(function()
        return loadingWin.IsLoading
    end)
    self.update = loadingWin.View.gameObject:AddComponent(typeof(CS.AssetbundleUpdater))
end

---@private _InitAppVersion 初始化App版本
function Update:_InitAppVersion()
    local streamingAppVersion = "0.0.0";
    local streamingResVersion = "0.0.0";
    local streamingChannel = "Test";

    --编辑器
    if CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.OSXEditor or
            CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.WindowsEditor or
            CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.LinuxEditor then
        --是否是Edit模式直接运行 不是AssetBundle
        if CS.AssetBundles.AssetBundleConfig.IsEditorMode then
            CS.GameChannel.ChannelManager.Instance.appVersion = streamingAppVersion
            CS.GameChannel.ChannelManager.Instance.resVersion = streamingResVersion
            self.channelName = streamingChannel
            return
        end
    end

    local loader = CS.AssetBundles.AssetBundleManager.Instance:RequestAssetFileAsync(CS.BuildUtils.AppVersionFileName)
    coroutine.waitforasyncop(loader)
    local streamingTxt = loader.text
    loader:Dispose()

    if not string.isNilOrEmpty(streamingTxt) then
        local strings = string.split(streamingTxt, '|')
        streamingAppVersion = strings[1]
        streamingResVersion = strings[2]
        streamingChannel = strings[3]
    end

    local persistentAppVersion = streamingAppVersion;
    local persistentResVersion = streamingResVersion;
    local persistentChannel = streamingChannel;

    local appVersionPath = CS.AssetBundles.AssetBundleUtility.GetPersistentDataPath(CS.BuildUtils.AppVersionFileName);
    local persistentTxt = CS.GameUtility.SafeReadAllText(appVersionPath);

    if string.isNilOrEmpty(persistentTxt) then
        CS.GameUtility.SafeWriteAllText(appVersionPath, streamingAppVersion .. "|" .. streamingResVersion .. "|" .. streamingChannel)
    else
        local strings = string.split(streamingTxt, '|')
        persistentAppVersion = strings[1]
        persistentResVersion = strings[2]
        persistentChannel = strings[3]
    end

    CS.GameChannel.ChannelManager.Instance.appVersion = persistentAppVersion
    CS.GameChannel.ChannelManager.Instance.resVersion = persistentResVersion
    self.channelName = persistentChannel
    Logger.Log(string.format("persistentResVersion = %s, persistentResVersion = %s, persistentChannel = %s",
            persistentAppVersion, persistentResVersion, persistentChannel))
    Logger.Log(string.format("streamingAppVersion = %s, streamingAppVersion = %s, streamingChannel = %s",
            streamingAppVersion, streamingResVersion, streamingChannel))

    -- 如果persistent目录版本比streamingAssets目录app版本低，说明是大版本覆盖安装，清理过时的缓存
    if (CS.BuildUtils.CheckIsNewVersion(persistentAppVersion, streamingAppVersion)) then

        Logger.Log("大版本覆盖安装，清理过时的缓存")

        CS.GameChannel.ChannelManager.Instance.appVersion = streamingAppVersion
        CS.GameChannel.ChannelManager.Instance.resVersion = streamingResVersion

        local path = CS.AssetBundles.AssetBundleUtility.GetPersistentDataPath()
        CS.GameUtility.SafeDeleteDir(path)
        CS.GameUtility.SafeWriteAllText(appVersionPath, streamingAppVersion .. "|" .. streamingResVersion .. "|" .. streamingChannel)
        -- 重启资源管理器
        coroutine.yieldreturn(AssetBundleManager.Instance.Cleanup())
        coroutine.yieldreturn(AssetBundleManager.Instance.Initialize())
    end
    Logger.Log("app版本初始化完成")
end

---@private _InitChannel 初始化渠道
function Update:_InitChannel()
    CS.GameChannel.ChannelManager.Instance:Init(self.channelName)
    Logger.Log(string.format("channelName = %s", self.channelName))
    coroutine.waitforframes(1)
end

---@private _InitSDK 初始化SDK
function Update:_InitSDK()
    CS.GameChannel.ChannelManager.Instance:InitSDK(function()
        Logger.Log("sdk 初始化完成")
    end)
    coroutine.waitforframes(1)
end

---@private _InitNoticeTipPrefab 初始化弹窗提示框
function Update:_InitNoticeTipPrefab()
    UIManager:GetInstance():OpenWindow(UIWindowNames.UINoticeTip, function(arge)
        Logger.Log("OpenWins", arge)
    end)
    local loadingWin = UIManager:GetInstance():GetWindow(UIWindowNames.UINoticeTip)
    coroutine.waitwhile(function()
        return loadingWin.IsLoading
    end)
    CS.UINoticeTip.Instance.UIGameObject = loadingWin.View.gameObject
    UIManager:GetInstance():CloseWindow(UIWindowNames.UINoticeTip)
    coroutine.waitforframes(1)
end

---@private _WaitVideoPlayerEnd 等待启动播放视频完成进入游戏
function Update:_WaitVideoPlayerEnd()
    local videoPlayer = GameObject.Find("LaunchVideo"):GetComponent("VideoPlayer")
    coroutine.waitwhile(function()
        if
        CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.LinuxEditor
                or CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.WindowsEditor
                or CS.UnityEngine.Application.platform == CS.UnityEngine.RuntimePlatform.OSXEditor
        then
            return false
        end
        return videoPlayer.isPlaying
    end)
    GameObject.Destroy(videoPlayer.gameObject);
    --local imgLogoBG = GameObject.Find("ImgLogoBG")
    --coroutine.waitforseconds(1)
    --GameObject.Destroy(imgLogoBG.gameObject);
end

---@private  _StartUpdateAssetRes 更新资源
function Update:_StartUpdateAssetRes()
    local start = self.update:StartCheckUpdate()
    require('XLua.Common.cs_coroutine').yield_return(start)
    Logger.Log("更新完成 ！！！！！清理更新的界面 遗留下的界面")
    UIManager:GetInstance():DestroyAllWindow(true);
    Logger.Log("更新完成 ！！！！！清理更新的界面 遗留下的界面 完成")
end

return Update